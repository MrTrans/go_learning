## MySQL全局锁与表锁
MySQL里面的锁大致可以分为全局锁、表级锁🔒和行锁三类<br>
### 锁的现象以及背后原理
#### 全局锁 对整个数据库实例加锁 FTWRL(Flush tables with read lock)
当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的数据更新语句，定义语句和更新类事务提交语句都会被阻塞。<br>
##### 应用场景 全库逻辑备份 把整个库每个表都select出来存成文本
为什么备份需要加锁？因为保持业务上的逻辑正确，不然出现时间差，备份与主库不一致。不加锁，逻辑不一致。事务隔离，可重复读，保持数据全部一致。官方自带逻辑备份工具是mysqldump。使用参数-single-transaction，导数据之前会启动一个事务，来确保拿到一致性视图。<br>
如果只读？readonly，(set global readonly = true)，1. readonly可能被拿来做逻辑 2. 异常处理机制上有差异。
**DML增删改数据，DDL加字段修改表结构的操作**<br>
#### 表级锁🔒  表锁与元数据锁(meta data lock,MDL)
表锁语法 lock tables ...read/write，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。限制所有线程操作对象。<br>
MDL(metadata lock)，不需要显式使用，在访问一个表的时候会被自动加上。保证读写的正确性。在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。<br>
MDL锁在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。<br>
#### 行锁 在引擎层由各个引擎自己实现，并不是所有引擎都支持行锁 Innodb支持行锁
行锁 就是针对数据表中行记录的锁，A更新了，B也要更新，要等A做完，B才能进行更新。
##### 两阶段锁说起 行锁实在需要的时候才加上的，但并不是不需要就立刻释放，而是要等到事务结束时才释放
如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放。<br>
死锁和死锁检测 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。<br>
解决策略：1 超时等待，innodb_lock_wait_timeout设置 2. 发起死锁检测，发现死锁，主动回滚死锁链条中国呢的某一个事务，让其他事务得以进行。innodb_deadlock_detect设置为on，表示开启这个逻辑<br>

